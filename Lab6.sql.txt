-- Part 1 Database Setup

-- Step 1.1 Create Sample Tables

-- Create table: employees
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    salary DECIMAL(10, 2)
);

-- Create table: departments
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50),
    location VARCHAR(50)
);

-- Create table: projects
CREATE TABLE projects (
    project_id INT PRIMARY KEY,
    project_name VARCHAR(50),
    dept_id INT,
    budget DECIMAL(10, 2)
);

-- Step 1.2 Insert Sample Data

-- Insert data into employees
INSERT INTO employees (emp_id, emp_name, dept_id, salary)
VALUES
(1, 'John Smith', 101, 50000),
(2, 'Jane Doe', 102, 60000),
(3, 'Mike Johnson', 101, 55000),
(4, 'Sarah Williams', 103, 65000),
(5, 'Tom Brown', NULL, 45000);

-- Insert data into departments
INSERT INTO departments (dept_id, dept_name, location) VALUES
(101, 'IT', 'Building A'),
(102, 'HR', 'Building B'),
(103, 'Finance', 'Building C'),
(104, 'Marketing', 'Building D');

-- Insert data into projects
INSERT INTO projects (project_id, project_name, dept_id, budget) VALUES
(1, 'Website Redesign', 101, 100000),
(2, 'Employee Training', 102, 50000),
(3, 'Budget Analysis', 103, 75000),
(4, 'Cloud Migration', 101, 150000),
(5, 'AI Research', NULL, 200000);

-- Part 2: CROSS JOIN EXERCISES

-- Exercise 2.1: Basic CROSS JOIN

-- Exercise 2.1: Basic CROSS JOIN
-- Show all possible combinations of employees and departments
SELECT e.emp_name, d.dept_name
FROM employees e CROSS JOIN departments d;

/* Question: How many rows does the result contain? Calculate N × M where N = number of employees, M = number of departments.
   Answer: 5 employees × 4 departments = 20 rows */

-- Exercise 2.2: Alternative CROSS JOIN Syntax
-- a) Comma notation
SELECT e.emp_name, d.dept_name
FROM employees e, departments d;

-- b) INNER JOIN with TRUE condition
SELECT e.emp_name, d.dept_name
FROM employees e
INNER JOIN departments d ON TRUE;

-- Exercise 2.3: Practical CROSS JOIN
-- Create a schedule showing all employees paired with all projects
SELECT e.emp_name, p.project_name
FROM employees e
CROSS JOIN projects p
ORDER BY e.emp_name, p.project_name;

-- Exercise 3.1: Basic INNER JOIN with ON
-- Display employees with their department names (only employees who have a department)
SELECT e.emp_name, d.dept_name, d.location
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

/* Question: How many rows are returned? Why is Tom Brown not included?
   Answer: 4 rows are returned. Tom Brown is not included because his dept_id is NULL,
   and INNER JOIN only returns rows where there is a match in both tables. */

-- Exercise 3.2: INNER JOIN with USING
-- Rewrite the query from Exercise 3.1 using the USING clause
SELECT emp_name, dept_name, location
FROM employees
INNER JOIN departments USING (dept_id);

/* Question: What's the difference in output columns compared to the ON version?
   Answer: With USING, the dept_id column appears only once in the result set,
   whereas with ON, you could have both e.dept_id and d.dept_id separately. */

-- Exercise 3.3: NATURAL INNER JOIN
-- Rewrite the query using NATURAL INNER JOIN
SELECT emp_name, dept_name, location
FROM employees
NATURAL INNER JOIN departments;

-- Exercise 3.4: Multi-table INNER JOIN
-- JOIN all three tables to show: employee name, department name, and project name
SELECT e.emp_name, d.dept_name, p.project_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
INNER JOIN projects p ON d.dept_id = p.dept_id;

-- Part 4: LEFT JOIN EXERCISES

-- Exercise 4.1: Basic LEFT JOIN
-- Show all employees with their department information, including employees without a department
SELECT e.emp_name, e.dept_id AS emp_dept, d.dept_id AS dept_dept, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

/* Question: How is Tom Brown represented in the results?
   Answer: Tom Brown appears in the results with his emp_dept as NULL,
   and the dept_dept and dept_name columns are also NULL since he has no matching department. */

-- Exercise 4.2: LEFT JOIN with USING
-- Rewrite Exercise 4.1 using the USING clause
SELECT e.emp_name, e.dept_id, d.dept_name
FROM employees e
LEFT JOIN departments d USING (dept_id);

-- Exercise 4.3: Find Unmatched Records
-- Find employees who are NOT assigned to any department
SELECT e.emp_name, e.dept_id
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
WHERE d.dept_id IS NULL;

-- Exercise 4.4: LEFT JOIN with Aggregation
-- Show all departments with the count of employees in each department (include departments with 0 employees)
SELECT d.dept_name, COUNT(e.emp_id) AS employee_count
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
ORDER BY employee_count DESC;


-- ============================================
-- PART 5: RIGHT JOIN EXERCISES
-- ============================================

-- Exercise 5.1: Basic RIGHT JOIN
-- Show all departments with their employees, including departments without employees
SELECT e.emp_name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id;

-- Exercise 5.2: Convert to LEFT JOIN
-- Rewrite Exercise 5.1 using LEFT JOIN instead of RIGHT JOIN (reverse the table order)
SELECT e.emp_name, d.dept_name
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id;

-- Exercise 5.3: Find Departments Without Employees
-- Identify departments that have no employees assigned
SELECT d.dept_name, d.location
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id
WHERE e.emp_id IS NULL;


-- ============================================
-- PART 6: FULL JOIN EXERCISES
-- ============================================

-- Exercise 6.1: Basic FULL JOIN
-- Show all employees and all departments, with NULL values where there's no match
SELECT e.emp_name, e.dept_id AS emp_dept, d.dept_id AS dept_dept, d.dept_name
FROM employees e
FULL JOIN departments d ON e.dept_id = d.dept_id;

/* Question: Which records have NULL values on the left side? Which have NULL on the right side?
   Answer:
   - Left side NULL: Marketing department (dept_id 104) has no employees, so emp_name and emp_dept are NULL
   - Right side NULL: Tom Brown (emp_id 5) has no department, so dept_dept and dept_name are NULL */

-- Exercise 6.2: FULL JOIN with Projects
-- Show all departments and all projects, including those without matches
SELECT d.dept_name, p.project_name, p.budget
FROM departments d
FULL JOIN projects p ON d.dept_id = p.dept_id;

-- Exercise 6.3: Find Orphaned Records
-- Using FULL JOIN, find both employees without departments AND departments without employees
SELECT
    CASE
        WHEN e.emp_id IS NULL THEN 'Department without employees'
        WHEN d.dept_id IS NULL THEN 'Employee without department'
        ELSE 'Matched'
    END AS record_status,
    e.emp_name,
    d.dept_name
FROM employees e
FULL JOIN departments d ON e.dept_id = d.dept_id
WHERE e.emp_id IS NULL OR d.dept_id IS NULL;


-- ============================================
-- PART 7: ON vs WHERE CLAUSE
-- ============================================

-- Exercise 7.1: Filtering in ON Clause (Outer Join)
-- Query with filter in ON clause
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id AND d.location = 'Building A';

-- Exercise 7.2: Filtering in WHERE Clause (Outer Join)
-- Same query but move the location filter to the WHERE clause
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
WHERE d.location = 'Building A';

/* Question: Compare the results of Query 1 and Query 2. Explain the difference.
   Answer:
   - Query 1 (ON clause): Applies the filter BEFORE the join, so all employees are included,
     but only departments in Building A are matched. Employees in other buildings show NULL
     for dept_name.
   - Query 2 (WHERE clause): Applies the filter AFTER the join, so employees are excluded
     if their department is not in Building A. This effectively converts the LEFT JOIN to
     an INNER JOIN behavior. */

-- Exercise 7.3: ON vs WHERE with INNER JOIN
-- Repeat exercises 7.1 and 7.2 using INNER JOIN instead of LEFT JOIN

-- Query with INNER JOIN and filter in ON
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id AND d.location = 'Building A';

-- Query with INNER JOIN and filter in WHERE
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
WHERE d.location = 'Building A';

/* Question: Is there any difference in results? Why or why not?
   Answer: NO difference. For INNER JOIN, filters in ON clause and WHERE clause produce
   the same results because both filter out non-matching rows. The distinction only matters
   for outer joins (LEFT, RIGHT, FULL). */


-- ============================================
-- PART 8: COMPLEX JOIN SCENARIOS
-- ============================================

-- Exercise 8.1: Multiple Joins with Different Types
-- Show all departments, include employee information (if any), include project information (if any)
SELECT
    d.dept_name,
    e.emp_name,
    e.salary,
    p.project_name,
    p.budget
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
LEFT JOIN projects p ON d.dept_id = p.dept_id
ORDER BY d.dept_name, e.emp_name;

-- Exercise 8.2: Self Join
-- Add a manager_id column to employees table and write a self-join query to show employees with their managers

-- Add manager_id column
ALTER TABLE employees ADD COLUMN manager_id INT;

-- Update with sample data
UPDATE employees SET manager_id = 3 WHERE emp_id = 1;
UPDATE employees SET manager_id = 3 WHERE emp_id = 2;
UPDATE employees SET manager_id = NULL WHERE emp_id = 3;
UPDATE employees SET manager_id = 3 WHERE emp_id = 4;
UPDATE employees SET manager_id = 3 WHERE emp_id = 5;

-- Self join query
SELECT
    e.emp_name AS employee,
    m.emp_name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.emp_id;

-- Exercise 8.3: Join with Subquery
-- Find departments where the average employee salary is above $50,000
SELECT d.dept_name, AVG(e.salary) AS avg_salary
FROM departments d
INNER JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
HAVING AVG(e.salary) > 50000;


-- ============================================
-- LAB QUESTIONS - ANSWERS
-- ============================================

/* 1. What is the difference between INNER JOIN and LEFT JOIN?
   Answer: INNER JOIN returns only rows that have matching values in both tables.
   LEFT JOIN returns all rows from the left table, and matching rows from the right table.
   If there's no match, NULL values are returned for the right table columns. */

/* 2. When would you use CROSS JOIN in a practical scenario?
   Answer: CROSS JOIN is useful when you need all possible combinations, such as:
   - Creating a calendar with all possible time slots
   - Generating test data with all combinations
   - Creating availability matrices (e.g., all employees × all projects)
   - Size charts (all sizes × all colors) */

/* 3. Explain why the position of a filter condition (ON vs WHERE) matters for outer joins but not for inner joins.
   Answer: For outer joins (LEFT, RIGHT, FULL):
   - ON clause: Filter is applied BEFORE the join, affecting which rows match but still
     preserving unmatched rows from the "preserved" table
   - WHERE clause: Filter is applied AFTER the join, potentially eliminating rows that
     the outer join would have preserved

   For inner joins: Both ON and WHERE produce the same result because only matching rows
   are kept anyway, so filtering before or after the match doesn't matter. */

/* 4. What is the result of: SELECT COUNT(*) FROM table1 CROSS JOIN table2
      if table1 has 5 rows and table2 has 10 rows?
   Answer: 50 rows (5 × 10 = 50) */

/* 5. How does NATURAL JOIN determine which columns to join on?
   Answer: NATURAL JOIN automatically joins tables based on columns with the same name
   in both tables. It's convenient but risky because:
   - It may join on unintended columns if column names coincidentally match
   - Schema changes can break queries unexpectedly
   - It's less explicit and harder to maintain */

/* 6. What are the potential risks of using NATURAL JOIN?
   Answer:
   - Implicit join conditions make queries less readable and maintainable
   - If tables have multiple columns with the same name, all are used for joining
   - Adding new columns with matching names can change query behavior unexpectedly
   - Different databases may implement NATURAL JOIN differently
   - Recommendation: Use explicit ON or USING clauses instead */

/* 7. Convert this LEFT JOIN to a RIGHT JOIN: SELECT * FROM A LEFT JOIN B ON A.id = B.id
   Answer: SELECT * FROM B RIGHT JOIN A ON A.id = B.id
   Or equivalently: SELECT * FROM B LEFT JOIN A ON B.id = A.id */

/* 8. When should you use FULL OUTER JOIN instead of other join types?
   Answer: Use FULL OUTER JOIN when you need to:
   - Find all records from both tables, including unmatched records
   - Identify orphaned records on either side
   - Perform data reconciliation or comparison
   - Create comprehensive reports showing all data from both sources
   - Example: Comparing two data sources to find discrepancies */


-- ============================================
-- ADDITIONAL CHALLENGES (OPTIONAL)
-- ============================================

-- Challenge 1: Simulate FULL OUTER JOIN using UNION of LEFT and RIGHT joins
-- (for databases that don't support FULL OUTER JOIN)
SELECT e.emp_name, e.dept_id, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
UNION
SELECT e.emp_name, e.dept_id, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id
WHERE e.emp_id IS NULL;

-- Challenge 2: Find employees who work in departments that have more than one project
SELECT DISTINCT e.emp_name, e.dept_id
FROM employees e
WHERE e.dept_id IN (
    SELECT dept_id
    FROM projects
    WHERE dept_id IS NOT NULL
    GROUP BY dept_id
    HAVING COUNT(*) > 1
);

-- Challenge 3: Create a hierarchical query showing the complete organizational structure
-- (employee → manager → manager's manager, etc.)
WITH RECURSIVE org_hierarchy AS (
    -- Base case: employees without managers (top level)
    SELECT emp_id, emp_name, manager_id, emp_name AS hierarchy_path, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case: employees with managers
    SELECT e.emp_id, e.emp_name, e.manager_id,
           oh.hierarchy_path || ' → ' || e.emp_name AS hierarchy_path,
           oh.level + 1 AS level
    FROM employees e
    INNER JOIN org_hierarchy oh ON e.manager_id = oh.emp_id
)
SELECT emp_name, hierarchy_path, level
FROM org_hierarchy
ORDER BY level, emp_name;

-- Part 1 Database Setup

-- Step 1.1 Create Sample Tables

-- Create table: employees
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    salary DECIMAL(10, 2)
);

-- Create table: departments
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50),
    location VARCHAR(50)
);

-- Create table: projects
CREATE TABLE projects (
    project_id INT PRIMARY KEY,
    project_name VARCHAR(50),
    dept_id INT,
    budget DECIMAL(10, 2)
);

-- Step 1.2 Insert Sample Data

-- Insert data into employees
INSERT INTO employees (emp_id, emp_name, dept_id, salary)
VALUES
(1, 'John Smith', 101, 50000),
(2, 'Jane Doe', 102, 60000),
(3, 'Mike Johnson', 101, 55000),
(4, 'Sarah Williams', 103, 65000),
(5, 'Tom Brown', NULL, 45000);

-- Insert data into departments
INSERT INTO departments (dept_id, dept_name, location) VALUES
(101, 'IT', 'Building A'),
(102, 'HR', 'Building B'),
(103, 'Finance', 'Building C'),
(104, 'Marketing', 'Building D');

-- Insert data into projects
INSERT INTO projects (project_id, project_name, dept_id, budget) VALUES
(1, 'Website Redesign', 101, 100000),
(2, 'Employee Training', 102, 50000),
(3, 'Budget Analysis', 103, 75000),
(4, 'Cloud Migration', 101, 150000),
(5, 'AI Research', NULL, 200000);

-- Part 2: CROSS JOIN EXERCISES

-- Exercise 2.1: Basic CROSS JOIN

-- Exercise 2.1: Basic CROSS JOIN
-- Show all possible combinations of employees and departments
SELECT e.emp_name, d.dept_name
FROM employees e CROSS JOIN departments d;

/* Question: How many rows does the result contain? Calculate N × M where N = number of employees, M = number of departments.
   Answer: 5 employees × 4 departments = 20 rows */

-- Exercise 2.2: Alternative CROSS JOIN Syntax
-- a) Comma notation
SELECT e.emp_name, d.dept_name
FROM employees e, departments d;

-- b) INNER JOIN with TRUE condition
SELECT e.emp_name, d.dept_name
FROM employees e
INNER JOIN departments d ON TRUE;

-- Exercise 2.3: Practical CROSS JOIN
-- Create a schedule showing all employees paired with all projects
SELECT e.emp_name, p.project_name
FROM employees e
CROSS JOIN projects p
ORDER BY e.emp_name, p.project_name;

-- Exercise 3.1: Basic INNER JOIN with ON
-- Display employees with their department names (only employees who have a department)
SELECT e.emp_name, d.dept_name, d.location
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

/* Question: How many rows are returned? Why is Tom Brown not included?
   Answer: 4 rows are returned. Tom Brown is not included because his dept_id is NULL,
   and INNER JOIN only returns rows where there is a match in both tables. */

-- Exercise 3.2: INNER JOIN with USING
-- Rewrite the query from Exercise 3.1 using the USING clause
SELECT emp_name, dept_name, location
FROM employees
INNER JOIN departments USING (dept_id);

/* Question: What's the difference in output columns compared to the ON version?
   Answer: With USING, the dept_id column appears only once in the result set,
   whereas with ON, you could have both e.dept_id and d.dept_id separately. */

-- Exercise 3.3: NATURAL INNER JOIN
-- Rewrite the query using NATURAL INNER JOIN
SELECT emp_name, dept_name, location
FROM employees
NATURAL INNER JOIN departments;

-- Exercise 3.4: Multi-table INNER JOIN
-- JOIN all three tables to show: employee name, department name, and project name
SELECT e.emp_name, d.dept_name, p.project_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
INNER JOIN projects p ON d.dept_id = p.dept_id;

-- Part 4: LEFT JOIN EXERCISES

-- Exercise 4.1: Basic LEFT JOIN
-- Show all employees with their department information, including employees without a department
SELECT e.emp_name, e.dept_id AS emp_dept, d.dept_id AS dept_dept, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

/* Question: How is Tom Brown represented in the results?
   Answer: Tom Brown appears in the results with his emp_dept as NULL,
   and the dept_dept and dept_name columns are also NULL since he has no matching department. */

-- Exercise 4.2: LEFT JOIN with USING
-- Rewrite Exercise 4.1 using the USING clause
SELECT e.emp_name, e.dept_id, d.dept_name
FROM employees e
LEFT JOIN departments d USING (dept_id);

-- Exercise 4.3: Find Unmatched Records
-- Find employees who are NOT assigned to any department
SELECT e.emp_name, e.dept_id
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
WHERE d.dept_id IS NULL;

-- Exercise 4.4: LEFT JOIN with Aggregation
-- Show all departments with the count of employees in each department (include departments with 0 employees)
SELECT d.dept_name, COUNT(e.emp_id) AS employee_count
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
ORDER BY employee_count DESC;


-- ============================================
-- PART 5: RIGHT JOIN EXERCISES
-- ============================================

-- Exercise 5.1: Basic RIGHT JOIN
-- Show all departments with their employees, including departments without employees
SELECT e.emp_name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id;

-- Exercise 5.2: Convert to LEFT JOIN
-- Rewrite Exercise 5.1 using LEFT JOIN instead of RIGHT JOIN (reverse the table order)
SELECT e.emp_name, d.dept_name
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id;

-- Exercise 5.3: Find Departments Without Employees
-- Identify departments that have no employees assigned
SELECT d.dept_name, d.location
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id
WHERE e.emp_id IS NULL;


-- ============================================
-- PART 6: FULL JOIN EXERCISES
-- ============================================

-- Exercise 6.1: Basic FULL JOIN
-- Show all employees and all departments, with NULL values where there's no match
SELECT e.emp_name, e.dept_id AS emp_dept, d.dept_id AS dept_dept, d.dept_name
FROM employees e
FULL JOIN departments d ON e.dept_id = d.dept_id;

/* Question: Which records have NULL values on the left side? Which have NULL on the right side?
   Answer:
   - Left side NULL: Marketing department (dept_id 104) has no employees, so emp_name and emp_dept are NULL
   - Right side NULL: Tom Brown (emp_id 5) has no department, so dept_dept and dept_name are NULL */

-- Exercise 6.2: FULL JOIN with Projects
-- Show all departments and all projects, including those without matches
SELECT d.dept_name, p.project_name, p.budget
FROM departments d
FULL JOIN projects p ON d.dept_id = p.dept_id;

-- Exercise 6.3: Find Orphaned Records
-- Using FULL JOIN, find both employees without departments AND departments without employees
SELECT
    CASE
        WHEN e.emp_id IS NULL THEN 'Department without employees'
        WHEN d.dept_id IS NULL THEN 'Employee without department'
        ELSE 'Matched'
    END AS record_status,
    e.emp_name,
    d.dept_name
FROM employees e
FULL JOIN departments d ON e.dept_id = d.dept_id
WHERE e.emp_id IS NULL OR d.dept_id IS NULL;


-- ============================================
-- PART 7: ON vs WHERE CLAUSE
-- ============================================

-- Exercise 7.1: Filtering in ON Clause (Outer Join)
-- Query with filter in ON clause
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id AND d.location = 'Building A';

-- Exercise 7.2: Filtering in WHERE Clause (Outer Join)
-- Same query but move the location filter to the WHERE clause
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
WHERE d.location = 'Building A';

/* Question: Compare the results of Query 1 and Query 2. Explain the difference.
   Answer:
   - Query 1 (ON clause): Applies the filter BEFORE the join, so all employees are included,
     but only departments in Building A are matched. Employees in other buildings show NULL
     for dept_name.
   - Query 2 (WHERE clause): Applies the filter AFTER the join, so employees are excluded
     if their department is not in Building A. This effectively converts the LEFT JOIN to
     an INNER JOIN behavior. */

-- Exercise 7.3: ON vs WHERE with INNER JOIN
-- Repeat exercises 7.1 and 7.2 using INNER JOIN instead of LEFT JOIN

-- Query with INNER JOIN and filter in ON
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id AND d.location = 'Building A';

-- Query with INNER JOIN and filter in WHERE
SELECT e.emp_name, d.dept_name, e.salary
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
WHERE d.location = 'Building A';

/* Question: Is there any difference in results? Why or why not?
   Answer: NO difference. For INNER JOIN, filters in ON clause and WHERE clause produce
   the same results because both filter out non-matching rows. The distinction only matters
   for outer joins (LEFT, RIGHT, FULL). */


-- ============================================
-- PART 8: COMPLEX JOIN SCENARIOS
-- ============================================

-- Exercise 8.1: Multiple Joins with Different Types
-- Show all departments, include employee information (if any), include project information (if any)
SELECT
    d.dept_name,
    e.emp_name,
    e.salary,
    p.project_name,
    p.budget
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
LEFT JOIN projects p ON d.dept_id = p.dept_id
ORDER BY d.dept_name, e.emp_name;

-- Exercise 8.2: Self Join
-- Add a manager_id column to employees table and write a self-join query to show employees with their managers

-- Add manager_id column
ALTER TABLE employees ADD COLUMN manager_id INT;

-- Update with sample data
UPDATE employees SET manager_id = 3 WHERE emp_id = 1;
UPDATE employees SET manager_id = 3 WHERE emp_id = 2;
UPDATE employees SET manager_id = NULL WHERE emp_id = 3;
UPDATE employees SET manager_id = 3 WHERE emp_id = 4;
UPDATE employees SET manager_id = 3 WHERE emp_id = 5;

-- Self join query
SELECT
    e.emp_name AS employee,
    m.emp_name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.emp_id;

-- Exercise 8.3: Join with Subquery
-- Find departments where the average employee salary is above $50,000
SELECT d.dept_name, AVG(e.salary) AS avg_salary
FROM departments d
INNER JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
HAVING AVG(e.salary) > 50000;


-- ============================================
-- LAB QUESTIONS - ANSWERS
-- ============================================

/* 1. What is the difference between INNER JOIN and LEFT JOIN?
   Answer: INNER JOIN returns only rows that have matching values in both tables.
   LEFT JOIN returns all rows from the left table, and matching rows from the right table.
   If there's no match, NULL values are returned for the right table columns. */

/* 2. When would you use CROSS JOIN in a practical scenario?
   Answer: CROSS JOIN is useful when you need all possible combinations, such as:
   - Creating a calendar with all possible time slots
   - Generating test data with all combinations
   - Creating availability matrices (e.g., all employees × all projects)
   - Size charts (all sizes × all colors) */

/* 3. Explain why the position of a filter condition (ON vs WHERE) matters for outer joins but not for inner joins.
   Answer: For outer joins (LEFT, RIGHT, FULL):
   - ON clause: Filter is applied BEFORE the join, affecting which rows match but still
     preserving unmatched rows from the "preserved" table
   - WHERE clause: Filter is applied AFTER the join, potentially eliminating rows that
     the outer join would have preserved

   For inner joins: Both ON and WHERE produce the same result because only matching rows
   are kept anyway, so filtering before or after the match doesn't matter. */

/* 4. What is the result of: SELECT COUNT(*) FROM table1 CROSS JOIN table2
      if table1 has 5 rows and table2 has 10 rows?
   Answer: 50 rows (5 × 10 = 50) */

/* 5. How does NATURAL JOIN determine which columns to join on?
   Answer: NATURAL JOIN automatically joins tables based on columns with the same name
   in both tables. It's convenient but risky because:
   - It may join on unintended columns if column names coincidentally match
   - Schema changes can break queries unexpectedly
   - It's less explicit and harder to maintain */

/* 6. What are the potential risks of using NATURAL JOIN?
   Answer:
   - Implicit join conditions make queries less readable and maintainable
   - If tables have multiple columns with the same name, all are used for joining
   - Adding new columns with matching names can change query behavior unexpectedly
   - Different databases may implement NATURAL JOIN differently
   - Recommendation: Use explicit ON or USING clauses instead */

/* 7. Convert this LEFT JOIN to a RIGHT JOIN: SELECT * FROM A LEFT JOIN B ON A.id = B.id
   Answer: SELECT * FROM B RIGHT JOIN A ON A.id = B.id
   Or equivalently: SELECT * FROM B LEFT JOIN A ON B.id = A.id */

/* 8. When should you use FULL OUTER JOIN instead of other join types?
   Answer: Use FULL OUTER JOIN when you need to:
   - Find all records from both tables, including unmatched records
   - Identify orphaned records on either side
   - Perform data reconciliation or comparison
   - Create comprehensive reports showing all data from both sources
   - Example: Comparing two data sources to find discrepancies */


-- ============================================
-- ADDITIONAL CHALLENGES (OPTIONAL)
-- ============================================

-- Challenge 1: Simulate FULL OUTER JOIN using UNION of LEFT and RIGHT joins
-- (for databases that don't support FULL OUTER JOIN)
SELECT e.emp_name, e.dept_id, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id
UNION
SELECT e.emp_name, e.dept_id, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id
WHERE e.emp_id IS NULL;

-- Challenge 2: Find employees who work in departments that have more than one project
SELECT DISTINCT e.emp_name, e.dept_id
FROM employees e
WHERE e.dept_id IN (
    SELECT dept_id
    FROM projects
    WHERE dept_id IS NOT NULL
    GROUP BY dept_id
    HAVING COUNT(*) > 1
);

-- Challenge 3: Create a hierarchical query showing the complete organizational structure
-- (employee → manager → manager's manager, etc.)
WITH RECURSIVE org_hierarchy AS (
    -- Base case: employees without managers (top level)
    SELECT emp_id, emp_name, manager_id, emp_name AS hierarchy_path, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case: employees with managers
    SELECT e.emp_id, e.emp_name, e.manager_id,
           oh.hierarchy_path || ' → ' || e.emp_name AS hierarchy_path,
           oh.level + 1 AS level
    FROM employees e
    INNER JOIN org_hierarchy oh ON e.manager_id = oh.emp_id
)
SELECT emp_name, hierarchy_path, level
FROM org_hierarchy
ORDER BY level, emp_name;

-- Challenge 4: Find all pairs of employees who work in the same department
SELECT
    e1.emp_name AS employee1,
    e2.emp_name AS employee2,
    d.dept_name
FROM employees e1
INNER JOIN employees e2 ON e1.dept_id = e2.dept_id AND e1.emp_id < e2.emp_id
INNER JOIN departments d ON e1.dept_id = d.dept_id
ORDER BY d.dept_name, e1.emp_name;