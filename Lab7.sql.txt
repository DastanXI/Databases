-- LAB 7

-- ============================================
-- PART 2 CREATING BASIC VIEWS
-- ============================================

-- Exercise 2.1 Simple View Creation
-- Create a view showing employee names with their department information
-- Include only employees who are assigned to a department
CREATE VIEW employee_details AS
SELECT
    e.emp_id,
    e.emp_name,
    e.salary,
    d.dept_name,
    d.location
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- Test your view
SELECT  FROM employee_details;

 Question How many rows are returned Why doesn't Tom Brown appear
   Answer 4 rows are returned. Tom Brown doesn't appear because
   - Tom Brown has a NULL dept_id (not assigned to any department)
   - The view uses INNER JOIN which only returns rows with matching values in both tables
   - Since Tom Brown has no matching department, he is excluded from the view 

-- Exercise 2.2 View with Aggregation
-- Create a view showing department statistics
CREATE VIEW dept_statistics AS
SELECT
    d.dept_id,
    d.dept_name,
    d.location,
    COUNT(e.emp_id) AS employee_count,
    COALESCE(AVG(e.salary), 0) AS avg_salary,
    COALESCE(MAX(e.salary), 0) AS max_salary,
    COALESCE(MIN(e.salary), 0) AS min_salary
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name, d.location;

-- Test your view
SELECT  FROM dept_statistics
ORDER BY employee_count DESC;

-- Exercise 2.3 View with Multiple Joins
-- Create a view showing complete project information
CREATE VIEW project_overview AS
SELECT
    p.project_id,
    p.project_name,
    p.budget,
    d.dept_name,
    d.location,
    COUNT(e.emp_id) AS team_size
FROM projects p
LEFT JOIN departments d ON p.dept_id = d.dept_id
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY p.project_id, p.project_name, p.budget, d.dept_name, d.location;

-- Test your view
SELECT  FROM project_overview
ORDER BY budget DESC;

-- Exercise 2.4 View with Filtering
-- Create a view for high earners (salary  $55,000)
CREATE VIEW high_earners AS
SELECT
    e.emp_name,
    e.salary,
    d.dept_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary  55000;

-- Test your view
SELECT  FROM high_earners;

 Question What happens when you query this view Can you see all high-earning employees
   Answer Yes, you can see all high-earning employees who are assigned to departments.
   The view shows Jane Doe (60000, HR) and Sarah Williams (65000, Finance).
   The WHERE condition filters data when the view is created, so it always returns
   only employees with salary  55000. 


-- ============================================
-- PART 3 MODIFYING AND MANAGING VIEWS
-- ============================================

-- Exercise 3.1 Replace a View
-- Modify the employee_details view to include a salary grade column
CREATE OR REPLACE VIEW employee_details AS
SELECT
    e.emp_id,
    e.emp_name,
    e.salary,
    d.dept_name,
    d.location,
    CASE
        WHEN e.salary  60000 THEN 'High'
        WHEN e.salary  50000 THEN 'Medium'
        ELSE 'Standard'
    END AS salary_grade
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- Test the updated view
SELECT  FROM employee_details
ORDER BY salary DESC;

-- Exercise 3.2 Rename a View
-- Rename the high_earners view to top_performers
ALTER VIEW high_earners RENAME TO top_performers;

-- Verify the rename
SELECT  FROM top_performers;

-- Exercise 3.3 Drop a View
-- Create a temporary view and then drop it
CREATE VIEW temp_view AS
SELECT emp_name, salary
FROM employees
WHERE salary  50000;

-- Test it
SELECT  FROM temp_view;

-- Drop the view
DROP VIEW temp_view;

-- Try to query it (this will fail)
-- SELECT  FROM temp_view;  -- Error relation temp_view does not exist


-- ============================================
-- PART 4 UPDATABLE VIEWS
-- ============================================

-- Exercise 4.1 Create an Updatable View
-- Create a simple updatable view on the employees table
CREATE VIEW employee_salaries AS
SELECT emp_id, emp_name, dept_id, salary
FROM employees;

-- Test your view
SELECT  FROM employee_salaries;

-- Exercise 4.2 Update Through a View
-- Update John Smith's salary to $52,000 through the view
UPDATE employee_salaries
SET salary = 52000
WHERE emp_name = 'John Smith';

-- Verify the update
SELECT  FROM employees WHERE emp_name = 'John Smith';

 Question Did the underlying table get updated
   Answer Yes , when you update data through a simple updatable view,
   the underlying base table (employees) is updated. John Smith's salary
   in the employees table is now $52,000. Views are just virtual representations,
   so updates pass through to the actual table. 

-- Exercise 4.3 Insert Through a View
-- Try inserting a new employee through the view
INSERT INTO employee_salaries (emp_id, emp_name, dept_id, salary)
VALUES (6, 'Alice Johnson', 102, 58000);

-- Check the employees table
SELECT  FROM employees WHERE emp_name = 'Alice Johnson';

 Question Was the insert successful Check the employees table.
   Answer YES! The insert was successful. Alice Johnson now appears in both
   the employee_salaries view and the employees table. Simple views that map
   directly to a single table allow INSERT operations. 

-- Exercise 4.4 View with CHECK OPTION
-- Create a view with LOCAL CHECK OPTION
CREATE VIEW it_employees AS
SELECT emp_id, emp_name, dept_id, salary
FROM employees
WHERE dept_id = 101
WITH LOCAL CHECK OPTION;

-- Test the view
SELECT  FROM it_employees;

-- Try to insert an employee from a different department
-- This should fail due to CHECK OPTION
INSERT INTO it_employees (emp_id, emp_name, dept_id, salary)
VALUES (7, 'Bob Wilson', 103, 60000);

 Question What error message do you receive Why
   Answer You receive an error like new row violates check option for view it_employees

   Why The WITH LOCAL CHECK OPTION ensures that any INSERT or UPDATE through the view
   must satisfy the view's WHERE clause (dept_id = 101). Since we tried to insert
   Bob Wilson with dept_id = 103 (Finance), it violates the check option and fails.

   This prevents users from inserting data through a view that wouldn't be visible
   in that view afterward. 


-- ============================================
-- PART 5 MATERIALIZED VIEWS
-- ============================================

-- Exercise 5.1 Create a Materialized View
-- Create a materialized view with department summary statistics
CREATE MATERIALIZED VIEW dept_summary_mv AS
SELECT
    d.dept_id,
    d.dept_name,
    d.location,
    COUNT(e.emp_id) AS total_employees,
    COALESCE(SUM(e.salary), 0) AS total_salaries,
    COUNT(p.project_id) AS total_projects,
    COALESCE(SUM(p.budget), 0) AS total_budget
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
LEFT JOIN projects p ON d.dept_id = p.dept_id
GROUP BY d.dept_id, d.dept_name, d.location
WITH DATA;

-- Query the materialized view
SELECT  FROM dept_summary_mv
ORDER BY total_employees DESC;

-- Exercise 5.2 Refresh Materialized View
-- Insert a new employee
INSERT INTO employees (emp_id, emp_name, dept_id, salary)
VALUES (8, 'Charlie Brown', 101, 54000);

-- Query the materialized view BEFORE refresh
SELECT  FROM dept_summary_mv WHERE dept_id = 101;
-- Notice IT department still shows old employee count

-- Refresh the materialized view
REFRESH MATERIALIZED VIEW dept_summary_mv;

-- Query AFTER refresh
SELECT  FROM dept_summary_mv WHERE dept_id = 101;
-- Now IT department shows updated employee count

 Question What's the difference before and after refresh
   Answer Before refresh, the materialized view shows outdated data (IT has 2 employees).
   After refresh, the materialized view shows current data (IT has 3 employees including Charlie).

   Key Difference Regular views query the base tables every time, always showing current data.
   Materialized views store a physical copy of the data, which is faster but can become stale.
   You must manually refresh materialized views to update the data. 

-- Exercise 5.3 Concurrent Refresh
-- Create a unique index on the materialized view
CREATE UNIQUE INDEX dept_summary_mv_idx ON dept_summary_mv(dept_id);

-- Refresh concurrently (allows queries during refresh)
REFRESH MATERIALIZED VIEW CONCURRENTLY dept_summary_mv;

 Question What's the advantage of CONCURRENTLY option
   Answer REFRESH MATERIALIZED VIEW CONCURRENTLY allows
   - Users can continue querying the materialized view DURING the refresh
   - No locking of the materialized view
   - No downtime for applications using the view

   Without CONCURRENT The view is locked during refresh, blocking queries.
   With CONCURRENT Queries can read the old data while the new data is being prepared.

   Requirement Must have a UNIQUE index on the materialized view to use CONCURRENTLY. 

-- Exercise 5.4 Materialized View with NO DATA
-- Create a materialized view without loading data immediately
CREATE MATERIALIZED VIEW project_stats_mv AS
SELECT
    p.project_id,
    p.project_name,
    p.budget,
    d.dept_name,
    COUNT(e.emp_id) AS assigned_employees
FROM projects p
LEFT JOIN departments d ON p.dept_id = d.dept_id
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY p.project_id, p.project_name, p.budget, d.dept_name
WITH NO DATA;

-- Try to query it (this will fail)
SELECT  FROM project_stats_mv;

 Question What error do you get How do you fix it
   Answer Error materialized view 'project_stats_mv' has not been populated

   Why WITH NO DATA creates the materialized view structure but doesn't load any data.
   This is useful when you want to set up the view definition but delay the expensive
   data population until later (e.g., during off-peak hours).

   How to fix Run REFRESH MATERIALIZED VIEW project_stats_mv; to populate it with data. 

-- Populate the materialized view
REFRESH MATERIALIZED VIEW project_stats_mv;

-- Now it works
SELECT  FROM project_stats_mv;


-- ============================================
-- PART 6 DATABASE ROLES
-- ============================================

-- Exercise 6.1 Create Basic Roles
-- Create a basic role (no login)
CREATE ROLE analyst;

-- Create a role with LOGIN and password
CREATE ROLE data_viewer WITH LOGIN PASSWORD 'viewer123';

-- Create a user (role with LOGIN capability)
CREATE ROLE report_user WITH LOGIN PASSWORD 'report456';

-- View all roles (excluding system roles)
SELECT rolname FROM pg_roles WHERE rolname NOT LIKE 'pg_%';

-- Exercise 6.2 Role with Specific Attributes
-- Create roles with different attributes

-- db_creator can create databases
CREATE ROLE db_creator WITH LOGIN PASSWORD 'creator789' CREATEDB;

-- user_manager can create roles
CREATE ROLE user_manager WITH LOGIN PASSWORD 'manager101' CREATEROLE;

-- admin_user superuser (use carefully!)
CREATE ROLE admin_user WITH LOGIN PASSWORD 'admin999' SUPERUSER;

-- View role attributes
SELECT
    rolname,
    rolsuper,
    rolinherit,
    rolcreaterole,
    rolcreatedb,
    rolcanlogin
FROM pg_roles
WHERE rolname IN ('db_creator', 'user_manager', 'admin_user', 'analyst', 'data_viewer', 'report_user')
ORDER BY rolname;

-- Exercise 6.3 Grant Privileges to Roles
-- Grant SELECT privilege on specific tables to analyst
GRANT SELECT ON employees TO analyst;
GRANT SELECT ON departments TO analyst;
GRANT SELECT ON projects TO analyst;

-- Grant ALL PRIVILEGES on a view to data_viewer
GRANT ALL PRIVILEGES ON employee_details TO data_viewer;

-- Grant SELECT and INSERT on employees to report_user
GRANT SELECT, INSERT ON employees TO report_user;

-- View granted privileges
SELECT
    grantee,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE grantee IN ('analyst', 'data_viewer', 'report_user')
ORDER BY grantee, table_name;

-- Exercise 6.4 Create Group Roles
-- Create group roles for different teams
CREATE ROLE hr_team;
CREATE ROLE finance_team;
CREATE ROLE it_team;

-- Create individual users
CREATE ROLE hr_user1 WITH LOGIN PASSWORD 'hr001';
CREATE ROLE hr_user2 WITH LOGIN PASSWORD 'hr002';
CREATE ROLE finance_user1 WITH LOGIN PASSWORD 'fin001';

-- Assign users to group roles
GRANT hr_team TO hr_user1;
GRANT hr_team TO hr_user2;
GRANT finance_team TO finance_user1;

-- Grant permissions to group roles
GRANT SELECT, UPDATE ON employees TO hr_team;
GRANT SELECT ON dept_statistics TO finance_team;

-- Verify role memberships
SELECT
    r.rolname AS role,
    m.rolname AS member
FROM pg_roles r
JOIN pg_auth_members am ON r.oid = am.roleid
JOIN pg_roles m ON am.member = m.oid
WHERE r.rolname IN ('hr_team', 'finance_team', 'it_team')
ORDER BY r.rolname;

-- Exercise 6.5 Revoke Privileges
-- Revoke UPDATE privilege from hr_team
REVOKE UPDATE ON employees FROM hr_team;

-- Revoke hr_team membership from hr_user2
REVOKE hr_team FROM hr_user2;

-- Revoke ALL PRIVILEGES on employee_details from data_viewer
REVOKE ALL PRIVILEGES ON employee_details FROM data_viewer;

-- Verify revocations
SELECT
    grantee,
    table_name,
    privilege_type
FROM information_schema.table_privileges
WHERE grantee IN ('hr_team', 'data_viewer')
ORDER BY grantee, table_name;

-- Exercise 6.6 Modify Role Attributes
-- Add LOGIN and password to analyst role
ALTER ROLE analyst WITH LOGIN PASSWORD 'analyst123';

-- Make user_manager a SUPERUSER
ALTER ROLE user_manager WITH SUPERUSER;

-- Remove password from analyst (set to NULL)
ALTER ROLE analyst WITH PASSWORD NULL;

-- Add a connection limit to data_viewer (max 5 concurrent connections)
ALTER ROLE data_viewer WITH CONNECTION LIMIT 5;

-- Verify the changes
SELECT
    rolname,
    rolcanlogin,
    rolsuper,
    rolconnlimit
FROM pg_roles
WHERE rolname IN ('analyst', 'user_manager', 'data_viewer')
ORDER BY rolname;


-- ============================================
-- PART 7 ADVANCED ROLE MANAGEMENT
-- ============================================

-- Exercise 7.1 Role Hierarchies
-- Create a parent role with basic read permissions
CREATE ROLE read_only;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO read_only;

-- Create child roles that inherit from read_only
CREATE ROLE junior_analyst WITH LOGIN PASSWORD 'junior123';
CREATE ROLE senior_analyst WITH LOGIN PASSWORD 'senior123';

-- Grant read_only membership to both analysts
GRANT read_only TO junior_analyst;
GRANT read_only TO senior_analyst;

-- Grant additional INSERT and UPDATE privileges to senior_analyst only
GRANT INSERT, UPDATE ON employees TO senior_analyst;

-- Test role hierarchy
SELECT
    r.rolname AS parent_role,
    m.rolname AS member_role,
    m.rolcanlogin AS can_login
FROM pg_roles r
JOIN pg_auth_members am ON r.oid = am.roleid
JOIN pg_roles m ON am.member = m.oid
WHERE r.rolname = 'read_only'
ORDER BY m.rolname;

-- Exercise 7.2 Object Ownership
-- Create a new role for project management
CREATE ROLE project_manager WITH LOGIN PASSWORD 'pm123';

-- Transfer ownership of dept_statistics view to project_manager
ALTER VIEW dept_statistics OWNER TO project_manager;

-- Transfer ownership of projects table to project_manager
ALTER TABLE projects OWNER TO project_manager;

-- Check ownership
SELECT
    tablename,
    tableowner
FROM pg_tables
WHERE schemaname = 'public'
UNION
SELECT
    viewname AS tablename,
    viewowner AS tableowner
FROM pg_views
WHERE schemaname = 'public'
ORDER BY tablename;

-- Exercise 7.3 Reassign and Drop Roles
-- Properly remove a role by reassigning its objects

-- 1. Create a role and give it ownership
CREATE ROLE temp_owner WITH LOGIN;
CREATE TABLE temp_table (id INT);
ALTER TABLE temp_table OWNER TO temp_owner;

-- 2. Transfer ownership to postgres (or another role)
REASSIGN OWNED BY temp_owner TO postgres;

-- 3. Drop all remaining privileges
DROP OWNED BY temp_owner;

-- 4. Drop the role
DROP ROLE temp_owner;

-- Exercise 7.4 Row-Level Security with Views
-- Create role-specific views that restrict data access

-- Create hr_employee_view showing only HR department employees
CREATE VIEW hr_employee_view AS
SELECT emp_id, emp_name, dept_id, salary
FROM employees
WHERE dept_id = 102;

-- Grant SELECT on this view to hr_team
GRANT SELECT ON hr_employee_view TO hr_team;

-- Create finance_employee_view showing only emp_id, name, and salary
-- (hiding dept_id for privacy)
CREATE VIEW finance_employee_view AS
SELECT emp_id, emp_name, salary
FROM employees;

-- Grant SELECT on this view to finance_team
GRANT SELECT ON finance_employee_view TO finance_team;

-- Now hr_team can only see HR employees
-- finance_team can see all employees but only limited columns


-- ============================================
-- PART 8 PRACTICAL SCENARIOS
-- ============================================

-- Exercise 8.1 Department Dashboard View
-- Create a comprehensive dashboard view for department managers
CREATE VIEW dept_dashboard AS
SELECT
    d.dept_name,
    d.location,
    COUNT(DISTINCT e.emp_id) AS employee_count,
    ROUND(AVG(e.salary), 2) AS avg_salary,
    COUNT(DISTINCT p.project_id) AS active_projects,
    COALESCE(SUM(p.budget), 0) AS total_project_budget,
    CASE
        WHEN COUNT(DISTINCT e.emp_id)  0 THEN
            ROUND(COALESCE(SUM(p.budget), 0)  COUNT(DISTINCT e.emp_id), 2)
        ELSE 0
    END AS budget_per_employee
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
LEFT JOIN projects p ON d.dept_id = p.dept_id
GROUP BY d.dept_id, d.dept_name, d.location
ORDER BY employee_count DESC;

-- Test the dashboard
SELECT  FROM dept_dashboard;

-- Exercise 8.2 Audit View
-- First, add a created_date column to projects table
ALTER TABLE projects ADD COLUMN created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Create view for high-value projects with approval status
CREATE VIEW high_budget_projects AS
SELECT
    p.project_name,
    p.budget,
    d.dept_name,
    p.created_date,
    CASE
        WHEN p.budget  150000 THEN 'Critical Review Required'
        WHEN p.budget  100000 THEN 'Management Approval Needed'
        ELSE 'Standard Process'
    END AS approval_status
FROM projects p
LEFT JOIN departments d ON p.dept_id = d.dept_id
WHERE p.budget  75000
ORDER BY p.budget DESC;

-- Test the audit view
SELECT  FROM high_budget_projects;

-- Exercise 8.3 Create Access Control System
-- Set up a complete access control system with multiple role levels

-- Level 1 - Viewer Role (read-only access)
CREATE ROLE viewer_role;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO viewer_role;

-- Level 2 - Entry Role (can insert data)
CREATE ROLE entry_role;
GRANT viewer_role TO entry_role;  -- Inherits viewer permissions
GRANT INSERT ON employees, projects TO entry_role;

-- Level 3 - Analyst Role (can update data)
CREATE ROLE analyst_role;
GRANT entry_role TO analyst_role;  -- Inherits entry permissions
GRANT UPDATE ON employees, projects TO analyst_role;

-- Level 4 - Manager Role (can delete data)
CREATE ROLE manager_role;
GRANT analyst_role TO manager_role;  -- Inherits analyst permissions
GRANT DELETE ON employees, projects TO manager_role;

-- Create Users and assign to roles
CREATE USER alice WITH PASSWORD 'alice123';
CREATE USER bob WITH PASSWORD 'bob123';
CREATE USER charlie WITH PASSWORD 'charlie123';

GRANT viewer_role TO alice;
GRANT analyst_role TO bob;
GRANT manager_role TO charlie;

-- Verify the complete role hierarchy
SELECT
    r.rolname AS role_name,
    ARRAY_AGG(m.rolname) AS members,
    r.rolcanlogin AS is_user
FROM pg_roles r
LEFT JOIN pg_auth_members am ON r.oid = am.roleid
LEFT JOIN pg_roles m ON am.member = m.oid
WHERE r.rolname IN ('viewer_role', 'entry_role', 'analyst_role', 'manager_role', 'alice', 'bob', 'charlie')
GROUP BY r.rolname, r.rolcanlogin
ORDER BY r.rolname;
